# es20XX

## es2017 (es8)

此笔记是根据一篇[CH前端社区](https://www.chinahtml.com/articles/28/)的文章进行学习整理的

### 字符串填充

> ES8 增加了两个新的函数： padStart 和 padEnd 。正如其名，这俩函数的作用就是在字符串的头部和尾部增加新的字符串，并且返回一个具有指定长度的新的字符串

代码语法 ：

```js
str.padStart(targetLength [, padString])

str.padEnd(targetLength [, padString])
```

> 第一个参数指的是设定这俩函数最后返回的字符串的长度 

如果传入的第一个参数，比原来的字符串的长度还要小，那么不会填充进去，原字符串不会发生任何改变

> 第二个参数是可选参数，代表你想要填充的内容，默认值是空格。

如果第二个参数非常长，当填充进去以后，超过了填充后的字符串的长度（第一个参数值），那么，第二个参数值就会被切割，取前面的部分去填充

具体代码示例：

```js
'es8'.padStart(2);          // 'es8'
'es8'.padStart(5);          // '  es8'
'es8'.padStart(6, 'woof');  // 'wooes8'
'es8'.padStart(14, 'wow');  // 'wowwowwowwoes8'
'es8'.padStart(7, '0');     // '0000es8'

'es8'.padEnd(2);          // 'es8'
'es8'.padEnd(5);          // 'es8  '
'es8'.padEnd(6, 'woof');  // 'es8woo'
'es8'.padEnd(14, 'wow');  // 'es8wowwowwowwo'
'es8'.padEnd(7, '6');     // 'es86666'
```

### values和entries函数

在 Object 中，ES8 也新增了两个新的函数，分别是 Object.values 函数和 ```Object.entries``` 函数。Object.values 函数将会返回一个数组，该数组的内容是函数参数（一个对象）可遍历属性的属性值。数组中得到的属性值的顺序与你在对参数对象使用 for in 语句时获取到的属性值的顺序一致。

代码语法：

```js
Object.values(obj);
```

参数 obj 就是源对象，它可以是一个对象或者一个数组（因为数组可以看作是数组下标为 key ，数组元素为 value 的特殊对象）。

当我们用数字作为键的时候，输出数组的顺序就会按照数字键的大小排序 --》 第68行

传入字符串，会将字符串的每个字符拆分成字符放到一个数组中 --》 第72行

具体代码示例：

```js
const obj = { x: 'xxx', y: 1 };
Object.values(obj); // ['xxx', 1]

const obj = ['e', 's', '8']; // same as { 0: 'e', 1: 's', 2: '8' };
Object.values(obj); // ['e', 's', '8']

// when we use numeric keys, the values returned in a numerical
// order according to the keys
const obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' };
Object.values(obj); // ['yyy', 'zzz', 'xxx']
Object.values('es8'); // ['e', 's', '8']
```

```Object.entries``` 函数与 ```Object.values``` 函数类似，也是返回一个数组，只不过这个数组是一个以源对象（参数）的可枚举属性的键值对为数组 [key, value] 的 n 行 2 列的数组。它的返回顺序与 ```Object.values``` 函数类似。

代码语法:

```js
Object.entries(obj);
```

数组或者字符串，会被添加上从0开始的索引

具体代码示例:

```js
const obj = { x: 'xxx', y: 1 };
Object.entries(obj); // [['x', 'xxx'], ['y', 1]]

const obj = ['e', 's', '8'];
Object.entries(obj); // [['0', 'e'], ['1', 's'], ['2', '8']]

const obj = { 10: 'xxx', 1: 'yyy', 3: 'zzz' };
Object.entries(obj); // [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]
Object.entries('es8'); // [['0', 'e'], ['1', 's'], ['2', '8']]
```

### getOwnPropertyDescriptors函数

Object 中还有一个新成员，那就是 ```Object.getOwnPropertyDescriptors``` 函数。该函数返回指定对象（参数）的所有自身属性描述符。所谓自身属性描述符就是在对象自身内定义，不是通过原型链继承来的属性

代码语法：

```js
Object.getOwnPropertyDescriptors(obj);
```

具体代码示例：

```js
var obj = {
    firstName : 'Adrien',
    conNum () {
        console.log(1);
    }
}

var res = Object.getOwnPropertyDescriptor(obj);
console.log(obj);

/*
{firstName: "Adrien", conNum: ƒ}
*/
```

### 结尾逗号

此处结尾逗号指的是在函数参数列表中最后一个参数之后的逗号以及函数调用时最后一个参数之后的逗号。ES8 允许在函数定义或者函数调用时，最后一个参数之后存在一个结尾逗号而不报 SyntaxError 的错误。示例代码如下：

```js
//函数定义
function es8(var1, var2, var3,) {
  // ...
}
//函数执行
es8(10, 20, 30,);
```

### 异步函数

由 async 关键字定义的函数声明定义了一个可以异步执行的函数，它返回一个 AsyncFunction 类型的对象。异步函数的内在运行机制和 Generator 函数非常类似，但是不能转化为 Generator 函数。

具体示例代码：

```js
function fetchTextByPromise() {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      resolve("es8");
    }, 2000);
  });
}
async function sayHello() {
  const externalFetchedText = await fetchTextByPromise();
  console.log(`Hello, ${externalFetchedText}`); // Hello, es8
}
sayHello();
1 // immediately
2 // immediately
Hello, es8 // after 2 seconds
```

### 标签函数（这个应该是和模板字符串一起出来的） 应该是es2016

> 标签函数的语法是函数名后面直接带一个模板字符串，并从模板字符串中的插值表达式中获取参数
> 标签函数的第一个参数是被嵌入表达式分隔的文本的数组。第二个参数开始是嵌入表达式的内容。

看一个例子来理解

```js
function greet(arg1, arg2, arg3){
  console.log(arg1);
  console.log(arg2);
  console.log(arg3);
}

// 普通函数
greet(["I'm ", ". I'm ", " years old."], name, age)

// tag 函数
greet`I'm ${name}. I'm ${age} years old.`、

// 最终输出
[ 'I\'m ', '. I\'m ', ' years old.' ]
Alfred
47
```

```js
function cook(strs, ...substs) {
    return substs.reduce(
        (prev,cur,i) => prev+cur+strs[i+1],
        strs[0]
    );
}

function repeat(times) {
    return function (...args) {
        return cook(...args).repeat(times);
    };
}

// 运行结果
> repeat(3)`abc`
'abcabcabc'
> repeat(3)`abc${3+1}`
'abc4abc4abc4'
```

### 共享内存与原子操作  ?????

当内存被共享时，多个线程可以并发读、写内存中相同的数据。原子操作可以确保那些被读、写的值都是可预期的，即新的事务是在旧的事务结束之后启动的，旧的事务在结束之前并不会被中断。这部分主要介绍了 ES8 中新的构造函数 SharedArrayBuffer 以及拥有许多静态方法的命名空间对象 Atomic 。

Atomic 对象类似于 Math 对象，拥有许多静态方法，所以我们不能把它当做构造函数。 Atomic 对象有如下常用的静态方法：

add /sub - 为某个指定的value值在某个特定的位置增加或者减去某个值
and / or /xor - 进行位操作
load - 获取特定位置的值

## es2018 （ES9）

根据一篇[掘金](https://juejin.im/post/6844903622870827022)的文章进行学习的

### 异步迭代

在同步循环中调用异步函数，不会正常执行，循环本身依旧保持同步，并在在内部异步函数之前全部调用完成。

下面是两个错误的代码

```js
async function process(array) {
  for (let i of array) {
    await doSomething(i);
  }
}
```

```js
async function process(array) {
  array.forEach(async i => {
    await doSomething(i);
  });
}
```

ES2018引入异步迭代器（asynchronous iterators），这就像常规迭代器，除了next()方法返回一个Promise。因此await可以和for...of循环一起使用，以串行的方式运行异步操作。

例如：

```js
async function process(array) {
  for await (let i of array) {
    doSomething(i);
  }
}
```

### Promise.finally()

一个Promise调用链要么成功到达最后一个.then()，要么失败触发.catch()。在某些情况下，你想要在无论Promise运行成功还是失败，运行相同的代码，例如清除，删除对话，关闭数据库连接等。

具体实例：

```js
function doSomething() {
  doSomething1()
  .then(doSomething2)
  .then(doSomething3)
  .catch(err => {
    console.log(err);
  })
  .finally(() => {
    // finish here!
  });
}
```

### Rest/Spread 属性

早在ES2015就引入了Rest参数和扩展运算符。三个点（...）仅用于数组。Rest参数语法允许我们将一个不定数量的参数表示为一个数组。

实例：

```js
restParam(1, 2, 3, 4, 5);

function restParam(p1, p2, ...p3) {
  // p1 = 1
  // p2 = 2
  // p3 = [3, 4, 5]
}
```

展开操作符以相反的方式工作，将数组转换成可传递给函数的单独参数。

```js
const values = [99, 100, -1, 48, 16];
console.log( Math.max(...values) ); // 100
```

ES2018为对象解构提供了和数组一样的Rest参数（）和展开操作符

一个简单的例子

```js
const myObject = {
  a: 1,
  b: 2,
  c: 3
};

const { a, ...x } = myObject;
// a = 1
// x = { b: 2, c: 3 }
```

或者你可以使用它给函数传递参数：

```js
restParam({
  a: 1,
  b: 2,
  c: 3
});

function restParam({ a, ...x }) {
  // a = 1
  // x = { b: 2, c: 3 }
}
```

跟数组一样，Rest参数只能在声明的结尾处使用。此外，它只适用于每个对象的顶层，如果对象中嵌套对象则无法适用

扩展运算符可以在其他对象内使用

```js
const obj1 = { a: 1, b: 2, c: 3 };
const obj2 = { ...obj1, z: 26 };
// obj2 is { a: 1, b: 2, c: 3, z: 26 }
```

用拓展运算符来克隆数组或者是对象，当里面的值全部是基本类型时，他是深克隆，当里面的值有非基本类型的值，他克隆的是里面的地址

```js
let arr1 = [1,2,3];
let arr2 = [...arr1];
arr1.push(3);
console.log(arr1, arr2);//[ 1, 2, 3, 3 ] [ 1, 2, 3 ]
```

```js
let arr1 = [1,2,[1,2,3]];

let arr2 = [...arr1];

arr1[2].push(3);

console.log(arr1, arr2); //[ 1, 2, [ 1, 2, 3, 3 ] ] [ 1, 2, [ 1, 2, 3, 3 ] ]
```

当然对象也是相同的道理

### 下面是正则表达式的新增内容

#### 正则表达式命名捕获组（Regular Expression Named Capture Groups）

在之前：JavaScript正则表达式可以返回一个匹配的对象——一个包含匹配字符串的类数组，例如：以YYYY-MM-DD的格式解析日期：

```js
const
  reDate = /([0-9]{4})-([0-9]{2})-([0-9]{2})/,
  match  = reDate.exec('2018-04-30'),
  year   = match[1], // 2018
  month  = match[2], // 04
  day    = match[3]; // 30
```

这样的代码很难读懂，并且改变正则表达式的结构有可能改变匹配对象的索引。

ES2018允许命名捕获组使用符号```?<name>```，在打开捕获括号(后立即命名)，示例如下：

```js
const
  reDate = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/,
  match  = reDate.exec('2018-04-30'),
  year   = match.groups.year,  // 2018
  month  = match.groups.month, // 04
  day    = match.groups.day;   // 30
```

match 是一个正则表达式对象，里面有一个groups 属性， 这个属性也是一个对象，里面就存储着我们在rep中定义的名字

任何匹配失败的命名组都将返回undefined。

命名捕获也可以使用在replace()方法中。例如将日期转换为美国的 MM-DD-YYYY 格式：

```js
const
  reDate = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/,
  d      = '2018-04-30',
  usDate = d.replace(reDate, '$<month>-$<day>-$<year>');
//替换的时候用的就是  ```$<name>```
```

#### 正则表达式反向断言（lookbehind） ?? --> 没看懂

目前JavaScript在正则表达式中支持先行断言（lookahead）。这意味着匹配会发生，但不会有任何捕获，并且断言没有包含在整个匹配字段中。例如从价格中捕获货币符号：

```js
const
  reLookahead = /\D(?=\d+)/,
  match       = reLookahead.exec('$123.89');
  console.log( match[0] ); // $
```

ES2018引入以相同方式工作但是匹配前面的反向断言（lookbehind），这样我就可以忽略货币符号，单纯的捕获价格的数字：

```js
const
  reLookbehind = /(?<=\D)\d+/,
  match        = reLookbehind.exec('$123.89');

console.log( match[0] ); // 123.89
```

以上是 肯定反向断言，非数字\D必须存在。同样的，还存在 否定反向断言，表示一个值必须不存在，例如：

```js
const
  reLookbehindNeg = /(?<!\D)\d+/,
  match           = reLookbehind.exec('$123.89');

console.log( match[0] ); // null
```

#### 正则表达式 ```dotAll``` 模式

正则表达式中点.匹配除回车外的任何单字符，标记s改变这种行为，允许行终止符的出现，

例如 ： 

```js
/hello.world/.test('hello\nworld');  // false
/hello.world/s.test('hello\nworld'); // true
```

#### 正则表达式 Unicode 转义

到目前为止，在正则表达式中本地访问 Unicode 字符属性是不被允许的。ES2018添加了 Unicode 属性转义——形式为\p{...}和\P{...}，在正则表达式中使用标记 u (unicode) 设置，在\p块儿内，可以以键值对的方式设置需要匹配的属性而非具体内容。

```js
const reGreekSymbol = /\p{Script=Greek}/u;
reGreekSymbol.test('π'); // true
```

#### 非转义序列的模板字符串

最后，ES2018 移除对 ECMAScript 在带标签的模版字符串中转义序列的语法限制。
之前，\u开始一个 unicode 转义，\x开始一个十六进制转义，\后跟一个数字开始一个八进制转义。这使得创建特定的字符串变得不可能，例如Windows文件路径 C:\uuu\xxx\111。更多细节参考模板字符串。


## ES2019 (ES10)

本笔记是根据[领英](https://blog.tildeloop.com/posts/javascript-what%E2%80%99s-new-in-es2019)和[简书](https://www.jianshu.com/p/fc43865811d5)的文章进行整理学习的

### String.prototype.trimStart() / String.prototype.trimEnd()

在接收用户输入的文本，我们经常会把头尾的空格文本去掉，来规避展示的不受控情况。自ES5来，```String.prototype.trim()``` 被用于去除头尾上的空格、换行符等，现在通过```trimStart()``` ，```trimEnd()```来头和尾进行单独控制。```trimLeft()```、```trimRight()```是他们的别名。

```js
const string = ' Hello ES2019! ';
string.trimStart();
// 'Hello ES2019! '
string.trimEnd();
// ' Hello ES2019!'
```

### Object.fromEntries()

ES8为我们引入了 ```Object.entries``` 把一个对象转为 ```[key, value]```键值对的形式，可以运用于像 Map 这种结构中。凡事有来有回，```Object.fromEntries()``` 用于把键值对还原成对象结构。

```js
let obj = {
  a : 1,
  b : 2,
  c : 3
}

for (let item of Object.entries(obj)) {
  console.log(item);
}

/**
[ 'a', 1 ]
[ 'b', 2 ]
[ 'c', 3 ]
 */
```

```js
let arr = [['foo', 'bar'], ['name', 'Oscar Hills']];
let obj = Object.fromEntries((arr));
console.log(obj);
//{ foo: 'bar', name: 'Oscar Hills' }
```